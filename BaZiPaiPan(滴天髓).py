# -*- coding: utf-8 -*-
import sys
import datetime
from argparse import Namespace
from collections import namedtuple
from lunar_python import Lunar, Solar
import sxtwl  # 用于四柱八字转日期的库
from sxtwl import GZ
from prettytable import PrettyTable

# 定义 namedtuple，用于存储四柱八字的天干和地支
Gans = namedtuple("Gans", "year month day time")
Zhis = namedtuple("Zhis", "year month day time")
天干列表 = ["甲", "乙", "丙", "丁", "戊", "己", "庚", "辛", "壬", "癸"]
地支列表 = ["子", "丑", "寅", "卯", "辰", "巳", "午", "未", "申", "酉", "戌", "亥"]
消失字典 = {}   #用于记录每个消失的天干或地支以及其消失的原因
计级字典 = {}
刑冲地支 = set()
合去地支 = set()
地支合次数 = {地支: 0 for 地支 in 地支列表}
# 假设有一个外部的 BaZi 类可以直接根据干支或日期计算八字（这只是占位示例）
class BaZi:
    def __init__(self, year_gz, month_gz, day_gz, time_gz):
        self.year_gan = year_gz[0]
        self.year_zhi = year_gz[1]
        self.month_gan = month_gz[0]
        self.month_zhi = month_gz[1]
        self.day_gan = day_gz[0]
        self.day_zhi = day_gz[1]
        self.time_gan = time_gz[0]
        self.time_zhi = time_gz[1]
    def getYearGan(self):
        return self.year_gan
    def getYearZhi(self):
        return self.year_zhi
    def getMonthGan(self):
        return self.month_gan
    def getMonthZhi(self):
        return self.month_zhi
    def getDayGan(self):
        return self.day_gan
    def getDayZhi(self):
        return self.day_zhi
    def getTimeGan(self):
        return self.time_gan
    def getTimeZhi(self):
        return self.time_zhi

# 定义辅助函数，用于根据干支组合（如"甲子"）返回sxtwl库所需的干支编号
# 注：sxtwl使用天干地支代号需通过 getGZ() 函数，本函数是占位。
def getGZ(gz_str):
    """
    将干支字符串转换为sxtwl.GZ对象
    例如：'甲子' -> GZ(0, 0)，'乙丑' -> GZ(1, 1) 等
    """
    if len(gz_str) != 2:
        raise ValueError(f"干支字符串必须是两个字符，当前是：{gz_str}")
    干 = gz_str[0]
    支 = gz_str[1]
    干索引 = 天干列表.index(干)
    支索引 = 地支列表.index(支) 
    return GZ(干索引, 支索引)

def 根据公历日期计算八字(options):
    """
    根据公历日期（options.year,options.month,options.day,options.time）计算八字
    
    options.g = True 代表公历  
    options.b = False 代表非直接八字输入（即使用日期转换）  
    输入格式：@机器人 男 1992 06 23 22
    """
    solar = Solar.fromYmdHms(int(options.year),
                             int(options.month),
                             int(options.day),
                             int(options.time),
                             0,
                             0)
    lunar = solar.getLunar()
    ba = lunar.getEightChar()  # 获取八字信息对象

    本命盘四个天干名字列表 = Gans(
        year=ba.getYearGan(),
        month=ba.getMonthGan(),
        day=ba.getDayGan(),
        time=ba.getTimeGan()
    )
    本命盘四个地支名字列表 = Zhis(
        year=ba.getYearZhi(),
        month=ba.getMonthZhi(),
        day=ba.getDayZhi(),
        time=ba.getTimeZhi()
    )
    return 本命盘四个天干名字列表, 本命盘四个地支名字列表

def 根据干支直接计算八字(options):
    """
    根据用户直接输入的四柱干支推断可能的公历日期，再获取八字。
    """
    # year, month, day, time 是如 "甲子"、"丙寅"这类干支组合
    year_gz = options.year
    month_gz = options.month
    day_gz = options.day
    time_gz = options.time

    try:
        # 将干支字符串转换为sxtwl需要的格式
        year_gz_index = getGZ(year_gz)
        month_gz_index = getGZ(month_gz)
        day_gz_index = getGZ(day_gz)
        time_gz_index = getGZ(time_gz)
        
        # 调用sxtwl的方法
        jds = sxtwl.siZhu2Year(
            year_gz_index,
            month_gz_index,
            day_gz_index,
            time_gz_index,
            options.start,
            int(options.end))
    except Exception as e:
        print(f"计算生日时出错：{e}")
        sys.exit(1)

    possible_dates = []
    for jd in jds:
        t = sxtwl.JD2DD(jd)
        # sxtwl.JD2DD返回的 t 包含公历年Y、月M、日D、时h
        possible_dates.append(datetime.datetime(int(t.Y), int(t.M), int(t.D), int(t.h), 0, 0))

    if not possible_dates:
        print("未找到可能的生日")
        sys.exit(1)

    # 策略：选择最接近当前年份的日期
    current_year = datetime.datetime.now().year
    chosen_date = min(
        (date for date in possible_dates if date.year <= current_year),
        key=lambda x: abs(x.year - current_year),
        default=possible_dates[0]  # 如无满足条件，则默认选第一个
    )

    # 选定日期后，再用该日期计算八字
    solar = Solar.fromYmdHms(chosen_date.year,
                             chosen_date.month,
                             chosen_date.day,
                             chosen_date.hour,
                             0,0)
    lunar = solar.getLunar()
    ba = lunar.getEightChar()

    本命盘四个天干名字列表 = Gans(
        year=ba.getYearGan(),
        month=ba.getMonthGan(),
        day=ba.getDayGan(),
        time=ba.getTimeGan()
    )
    本命盘四个地支名字列表 = Zhis(
        year=ba.getYearZhi(),
        month=ba.getMonthZhi(),
        day=ba.getDayZhi(),
        time=ba.getTimeZhi()
    )
    return 本命盘四个天干名字列表, 本命盘四个地支名字列表


def 解析输入命令():
    """
    从命令行解析用户输入。
    假设输入格式为：
    - 公历输入法示例：@机器人 男 1990 12 06 22
    - 四柱八字输入法示例：@机器人 女 甲 子 丙 寅 丁 丑 戌 亥
    """
    # 从sys.stdin读取一行命令，如不需要交互，可直接传入sys.argv
    line = sys.stdin.readline().strip()
    if not line:
        print("未检测到输入，请输入命令")
        sys.exit(1)

    parts = line.split()
    if len(parts) < 3:
        print("输入格式有误")
        sys.exit(1)

    # parts[0]应为"@机器人"
    # parts[1]应为"男"或"女"
    # parts[2]开始根据是否数字判断输入方式
    at_cmd = parts[0]
    gender_str = parts[1]

    if at_cmd != "@机器人":
        print("未检测到@机器人指令")
        sys.exit(1)

    options = Namespace()
    # 性别变量 n，True为女，False为男
    options.n = (gender_str == "女")

    if parts[2].isdigit():
        # 公历输入法
        if len(parts) != 6:
            print("公历输入法格式错误，请输入@机器人 性别 年 月 日 时")
            sys.exit(1)
        options.year = parts[2]
        options.month = parts[3]
        options.day = parts[4]
        options.time = parts[5]
        # 公历输入标记
        options.g = True
        # 非直接八字输入
        options.b = False
        # 闰月标记（这里默认为False）
        options.r = False
        # 默认起始和结束年
        options.start = 1850
        options.end = '2030'
    else:
        # 四柱八字输入法
        if len(parts) < 10:
            print("四柱八字输入法格式错误，请输入@机器人 性别 年干 年支 月干 月支 日干 日支 时干 时支")
            sys.exit(1)
        # 干支组合
        年干 = parts[2]
        年支 = parts[3]
        月干 = parts[4]
        月支 = parts[5]
        日干 = parts[6]
        日支 = parts[7]
        时干 = parts[8]
        时支 = parts[9]
        options.year = 年干 + 年支
        options.month = 月干 + 月支
        options.day = 日干 + 日支
        options.time = 时干 + 时支
        # 公历标记：False
        options.g = False
        # 直接输入八字
        options.b = True
        # 闰月标记（这里默认为False）
        options.r = False
        # 默认起始和结束年
        options.start = 1801
        options.end = '2040'
    return options






#省略前面的输入部分的代码

十天干五行对照表 = {"甲": "木", "乙": "木", "丙": "火", "丁": "火", "戊": "土", "己": "土", "庚": "金", "辛": "金", "壬": "水", "癸": "水"}
十天干的五行和阴阳表 = {"甲": ("阳", "木"),"乙": ("阴", "木"),"丙": ("阳", "火"),"丁": ("阴", "火"),"戊": ("阳", "土"),"己": ("阴", "土"),"庚": ("阳", "金"),"辛": ("阴", "金"),"壬": ("阳", "水"),"癸": ("阴", "水")}
十二地支五行对照表 = {"子": "水", "丑": "土", "寅": "木", "卯": "木", "辰": "土", "巳": "火", "午": "火", "未": "土", "申": "金", "酉": "金", "戌": "土", "亥": "水"}
五行作用关系 = {("金", "金"): '同', ("金", "木"): '克', ("金", "水"): '生', ("金", "火"): '耗', ("金", "土"): '泄',("木", "木"): '同', ("木", "土"): '克', ("木", "火"): '生', ("木", "金"): '耗', ("木", "水"): '泄',
("水", "水"): '同', ("水", "火"): '克', ("水", "木"): '生', ("水", "土"): '耗', ("水", "金"): '泄',("火", "火"): '同', ("火", "金"): '克', ("火", "土"): '生', ("火", "水"): '耗', ("火", "木"): '泄',
("土", "土"): '同', ("土", "水"): '克', ("土", "金"): '生', ("土", "木"): '耗', ("土", "火"): '泄'}
def 五行作用后增减力(五行1, 五行2):
    """
    计算两个五行属性之间的作用关系对双方的影响
    参数:
    五行1: 主动方的五行属性 (如"金")
    五行2: 被动方的五行属性 (如"木")
    返回:
    tuple: (主动方影响, 被动方影响)，每个影响为 "增力"/"减力"/"不变"
    """
    作用 = 五行作用关系.get((五行1, 五行2))
    if not 作用:
        return "未知", "未知"
    影响对照 = {
        "生": ("减力", "增力"),  # A生B: A减力，B增力
        "泄": ("增力", "减力"),  # A泄B: A增力，B减力
        "克": ("不变", "减力"),  # A克B: A不变，B减力
    }
    
    return 影响对照.get(作用)

地支藏干字典 = {'寅': ['甲', '丙', '戊'], '申': ['庚', '壬'], '巳': ['庚', '丙', '戊'], '亥': ['壬', '甲'],
    '子': ['癸'], '午': ['丁', '己'], '卯': ['乙'], '酉': ['辛'],
    '辰': ['乙', '戊', '癸'], '戌': ['辛', '丁', '戊'], '丑': ['癸', '辛', '己'], '未': ['乙', '己', '丁']}
四马 = ["寅", "申", "巳", "亥"]
四正 = ["子", "午", "卯", "酉"]
四正地支的本气 = {'子': '癸', '午': '丁', '卯': '乙', '酉': '辛'}
四库 = ["辰", "戌", "丑", "未"]
四库地支的本气 = {'辰': '戊', '戌': '戊', '丑': '己', '未': '己'}
库神 = {'辰': ['壬', '辛'], '戌': ['丙', '戊', '乙'],'丑': ['庚', '丁', '己'],'未': ['甲', '癸']}

三会局字典 = {'亥卯未': ['甲', '乙'], '亥卯': ['甲', '乙'], '卯未': ['甲', '乙'], '亥未': ['甲'],
    '申子辰': ['壬', '癸'], '申子': ['壬', '癸'], '子辰': ['壬', '癸'], '申辰': ['壬'],
    '寅午戌': ['丙', '丁'], '寅午': ['丙', '丁'], '午戌': ['丙', '丁'], '寅戌': ['丙'],
    '巳酉丑': ['庚', '辛'], '巳酉': ['庚', '辛'], '酉丑': ['庚', '辛'], '巳丑': ['庚']}
三会方字典 = {'亥子丑': ['壬', '癸'], '寅卯辰': ['甲', '乙'], '巳午未': ['丙', '丁'], '申酉戌': ['庚', '��']}
地支六冲 = {'子午': '冲', '卯酉': '冲', '寅申': '冲', '巳亥': '冲', '辰戌': '冲', '丑未': '冲'}
刑字典 = {'寅巳': ['刑'], '丑戌': ['刑'], '未戌': ['刑'], '午午': ['刑'], '酉酉': ['刑'], '亥亥': ['刑']}

# 定义一个辅助函数，用于计算天干或地支的阴阳属性
def 字的阴阳属性(item):
    if item in 天干列表:
        return '阳' if 天干列表.index(item) % 2 == 0 else '阴'
    elif item in 地支列表:
        return '阳' if 地支列表.index(item) % 2 == 0 else '阴'
    else:
        return None


# 检查地支是否冲
def 检查地支是否冲(地支组合):
    """
    输入地支位置和地支组合，判断是否有冲发生。
    地支位置：如 ['年支', '月支', '日支', '时支']
    地支组合：如 ['子', '午', '卯', '酉']
    """
    冲结果 = []
    for i in range(len(地支组合) - 1):
        支1, 支2 = 地支组合[i], 地支组合[i + 1]
        if f"{支1}{支2}" in 地支六冲 or f"{支2}{支1}" in 地支六冲:
            冲结果.append((支1, 支2))
            处理刑冲结果(支1, 支2, "冲")
    return 冲结果

def 检查地支是否刑(地支组合):
    """
    检查地支是否刑并处理结果
    """
    刑结果 = []
    for i in range(len(地支组合) - 1):
        支1, 支2 = 地支组合[i], 地支组合[i + 1]
        if f"{支1}{支2}" in 刑字典 or f"{支2}{支1}" in 刑字典:
            刑结果.append((支1, 支2))
            处理刑冲结果(支1, 支2, "刑")  # 修正这里的函数名
    return 刑结果

# 检查三会局中的会出者
def 检查三会局(地支组合):
    地支集合 = set(地支组合)  # 使用集合进行包含检查
    会出者 = []
    # 检查所有可能的会局
    for 会局, 会出 in 三会局字典.items():
        if set(会局) <= 地支集合:
            会出者.extend(会出)
    return list(set(会出者))  # 去重返回

# 检查三会方中的会出者
def 检查三会方(地支组合, 刑冲合去地支):
    地支集合 = set(地支组合)
    会出者 = []

    for 三会组, 会出 in 三会方字典.items():
        if set(三会组) <= 地支集合 and not set(三会组) & 刑冲合去地支:
            会出者.extend(会出)

    return list(set(会出者))  # 去重返回

def 获取刑冲合去地支(地支组合):
    """获取相邻地支间的刑冲关系导致的失效地支"""
    刑冲合去地支 = set()
    for i in range(len(地支组合) - 1):
        支1, 支2 = 地支组合[i], 地支组合[i + 1]
        组合1, 组合2 = f"{支1}{支2}", f"{支2}{支1}"
        # 检查刑
        if 组合1 in 刑字典 or 组合2 in 刑字典:
            刑冲合去地支.update([支1, 支2])
        # 检查冲
        if 组合1 in 地支六冲 or 组合2 in 地支六冲:
            刑冲合去地支.update([支1, 支2])
    return 刑冲合去地支

# 定义地支对应的本气
def 处理刑冲结果(地支1, 地支2, 类型="刑", 已消失地支=None, 已消失天干=None):
    if 已消失地支 is None:
        已消失地支 = set()
    if 已消失天干 is None:
        已消失天干 = set()

    # 记录地支消失的原因
    消失字典[地支1] = f"({地支1}地支)"
    消失字典[地支2] = f"({地支2}地支)"
    
    # 将地支添加到已消失集合
    已消失地支.update([地支1, 地支2])
    
    # 将地支添加到刑冲地支集合
    刑冲地支.update([地支1, 地支2])
    
    # 处理人元(地支藏干)和库神，但保留"本气"
    for 地支 in [地支1, 地支2]:
        本气 = 四库地支的本气.get(地支)
        for 藏干 in 地支藏干字典.get(地支, []):
            if 藏干 != 本气:
                消失字典[藏干] = f"('{地支}'的人元)"
                已消失天干.add(藏干)
        for 库神干 in 库神.get(地支, []):
            消失字典[库神干] = f"('{地支}'的库神)"
            已消失天干.add(库神干)
    
    # 处理特殊情况下余下的天干等级
    if 类型 == "刑":
        if (地支1 == "丑" and 地支2 == "戌") or (地支1 == "戌" and 地支2 == "丑"):
            计级字典["己"] = "6级"
            计级字典["戊"] = "6级"
        elif (地支1 == "未" and 地支2 == "戌") or (地支1 == "戌" and 地支2 == "未"):
            计级字典["己"] = "3级"
            计级字典["戊"] = "6级"
        elif 地支1 == "辰" and 地支2 == "辰":
            计级字典["戊"] = "6级"
    
    elif 类型 == "冲":
        if (地支1 == "辰" and 地支2 == "戌") or (地支1 == "戌" and 地支2 == "辰"):
            计级字典["戊"] = "6级"
        elif (地支1 == "丑" and 地支2 == "未") or (地支1 == "未" and 地支2 == "丑"):
            计级字典["己"] = "6级"


# 定义天干五合规则
天干五合 = {"甲己", "乙庚", "丙辛", "丁壬", "戊癸"}

def 检查天干相邻(天干位置):
    """
    判断两个天干是否相邻，遵循"隔日干不为隔"原则
    参数:
    天干位置: ['年干', '月干', '日干', '时干']
    返回: 所有相邻的天干对
    """
    相邻对 = []
    # 年干和月干相邻
    相邻对.append(('年干', '月干'))
    # 月干和时干相邻（隔日干不为隔）
    相邻对.append(('月干', '时干'))
    return 相邻对


def 判断天干有伤(天干, 天干组合, 会出者, 地支组合, 藏干):
    """
    判断天干是否有伤
    参数:
    天干: 需要判断的天干
    天干组合: 命局中的天干（透干）
    会出者: 命局中的会出者
    地支组合: 命局中的地支
    藏干: 地支藏干字典
    
    返回: True表示有伤，False表示无伤
    """
    # 1) 检查是否被其他透干同性克泄
    for 其他天干 in 天干组合:
        if 其他天干 != 天干 and 十天干的五行和阴阳表[其他天干][0] == 十天干的五行和阴阳表[天干][0]:
            if 五行作用关系.get((十天干五行对照表[其他天干], 十天干五行对照表[天干])) in ['克', '泄']:
                return True
    
    # 2) 检查是否被会出者同性克泄
    for 会出 in 会出者:
        if 十天干的五行和阴阳表[会出][0] == 十天干的五行和阴阳表[天干][0]:
            if 五行作用关系.get((十天干五行对照表[会出], 十天干五行对照表[天干])) in ['克', '泄']:
                return True
    
    # 3) 检查是否被地支本气同性克泄
    for 地支 in 地支组合:
        地支五行 = 十二地支五行对照表[地支]
        # 获取地支的本气（与地支五行相同的藏干）
        for 藏干字 in 地支藏干字典.get(地支, []):
            if 十天干五行对照表[藏干字] == 地支五行:  # 是本气
                if 十天干的五行和阴阳表[藏干字][0] == 十天干的五行和阴阳表[天干][0]:
                    if 五行作用关系.get((十天干五行对照表[藏干字], 十天干五行对照表[天干])) in ['克', '泄']:
                        return True
    
    return False


def 处理天干五合(天干组合, 天干位置, 会出者, 地支组合, 藏干, 已消失天干):
    """
    处理天干五合关系
    参数:
    天干组合: 命局中的天干
    天干位置: 天干的位置信息
    会出者: 命局中的会出者
    地支组合: 命局中的地支
    藏干: 地支藏干字典
    已消失天干: set，记录已消失的天干
    
    返回: 合留集合和合去集合
    """
    合留 = set()
    合去 = set()
    # 使用布尔标志记录每个天干的合状态，False表示合去，True表示合留
    合状态 = {天干: False for 天干 in 天干组合}
    
    # 获取相邻的天干对
    相邻天干对 = 检查天干相邻(天干位置)
    
    # 检查每对相邻天干是否构成五合
    for 位置1, 位置2 in 相邻天干对:
        位置索引 = {'年干': 0, '月干': 1, '日干': 2, '时干': 3}
        天干1 = 天干组合[位置索引[位置1]]
        天干2 = 天干组合[位置索引[位置2]]
        
        组合 = f"{天干1}{天干2}"
        反组合 = f"{天干2}{天干1}"
        
        # 检查是否构成五合
        if 组合 in 天干五合 or 反组合 in 天干五合:
            for 天干 in [天干1, 天干2]:
                # 切换合状态
                合状态[天干] = not 合状态[天干]
                if 合状态[天干]:
                    合留.add(天干)
                    合去.discard(天干)
                else:
                    合去.add(天干)
                    合留.discard(天干)
    
    # 更新消失字典和已消失天干集合
    for 天干 in 合去:
        # 找出天干的位置
        for idx, tg in enumerate(天干组合):
            if tg == 天干:
                if idx == 0:
                    位置 = "年干"
                elif idx == 1:
                    位置 = "月干"
                elif idx == 2:
                    位置 = "日干"
                elif idx == 3:
                    位置 = "时干"
                消失字典[天干] = f"({位置})"
                已消失天干.add(天干)
                break  # 假设每个天干只出现在一个位置
    
    return 合留, 合去

# 地支六合规则
地支六合 = {"子丑", "寅亥", "卯戌", "辰酉", "巳申", "午未"}

# 判断两个地支是否相邻
def 检查地支相邻(地支位置):
    """
    输入：地支位置列表，例如 ['年支', '月支', '日支', '时支']
    输出：所有相邻的地支对及其位置索引
    """
    相邻对 = []
    for i in range(len(地支位置) - 1):
        相邻对.append((地支位置[i],地支位置[i + 1]))
    return 相邻对

# 判断地支是否有伤
def 判断地支有伤(地支, 天干组合, 地支组合, 会出者, 藏干, 六合对):
    """
    判断地支是否有伤
    参数:
    地支: 需要判断的地支
    天干组合: 命局中的天干
    地支组合: 命局中的地支
    会出者: 命局中的会出者
    藏干: 地支藏干字典
    六合对: 当前正在判断的六��两个地支

    返回: True表示有伤，False表示无伤
    """
    # 获取当前地支的本气（与地支五行属性相同的人元）
    本地支五行 = 十二地支五行对照表[地支]
    本气列表 = []
    for 人元 in 地支藏干字典.get(地支, []):
        if 十天干五行对照表[人元] == 本地支五行:
            本气列表.append(人元)
    
    # 1) 检查本气是否被透干同性克泄
    for 本气 in 本气列表:
        for 天干 in 天干组合:
            if (十天干的五行和阴阳表[天干][0] == 十天干的五行和阴阳表[本气][0]and 
                五行作用关系.get((十天干五行对照表[天干], 十天干五行对照表[本气])) in ['克', '泄']):
                return True

    # 2) 检查本气是否被会出者同性克泄
    for 本气 in 本气列表:
        for 会出 in 会出者:
            if (十天干的五行和阴阳表[会出][0] == 十天干的五行和阴阳表[本气][0] and 
                五行作用关系.get((十天干五行对照表[会出], 十天干五行对照表[本气])) in ['克', '泄']):
                return True

    # 3) 检查除六合对外的其他地支的本气是否对该地支的本气有同性克泄
    for 其他地支 in 地支组合:
        if 其他地支 not in 六合对:  # 排除六合对中的地支
            其他本气 = []
            其他地支五行 = 十二地支五行对照表[其他地支]
            for 人元 in 地支藏干字典.get(其他地支, []):
                if 十天干五行对照表[人元] == 其他地支五行:
                    其他本气.append(人元)
            
            for 本气 in 本气列表:
                for 其他本气字 in 其他本气:
                    if (十天干的五行和阴阳表[其他本气字][0] == 十天干的五行和阴阳表[本气][0] and 
                        五行作用关系.get((十天干五行对照表[其他本气字], 十天干五行对照表[本气])) in ['克', '泄']):
                        return True

    # 4) 检查与相邻地支是否有刑冲关系
    # 遍历所有地支的位置
    for idx, current地支 in enumerate(地支组合):
        if current地支 != 地支:
            continue
        # 检查前一个地支
        if idx > 0:
            前地支 = 地支组合[idx-1]
            if (f"{地支}{前地支}" in 刑字典 or f"{前地支}{地支}" in 刑字典 or
                f"{地支}{前地支}" in 地支六冲 or f"{前地支}{地支}" in 地支六冲):
                return True
        
        # 检查后一个地支
        if idx < len(地支组合)-1:
            后地支 = 地支组合[idx+1]
            if (f"{地支}{后地支}" in 刑字典 or f"{后地支}{地支}" in 刑字典 or
                f"{地支}{后地支}" in 地支六冲 or f"{后地支}{地支}" in 地支六冲):
                return True

    return False

# 检查是否满足地支六合条件
def 处理地支六合(六合对结果, 天干组合, 地支组合, 会出者, 藏干, 已消失地支, 已消失天干, 地支合次数):
    合留 = set()
    合去 = set()
    
    for 地支1, 地支2 in 六合对结果:
        for 地支 in [地支1, 地支2]:
            if 地支合次数[地支] == 0:
                # 第一次遇到六合，检查是否有伤
                有伤 = 判断地支有伤(地支, 天干组合, 地支组合, 会出者, 藏干, (地支1, 地支2))
                if 有伤:
                    # 合留
                    合留.add(地支)
                    print(f"地支 {地支} 因有伤而合留")
                else:
                    # 合去
                    合去.add(地支)
                    消失字典[地支] = "合去"
                    已消失地支.add(地支)
                    合去地支.add(地支)
                    print(f"地支 {地支} 因无伤而合去")
            else:
                # 第二次及以后遇到六合，直接合去
                合去.add(地支)
                消失字典[地支] = "合去"
                已消失地支.add(地支)
                合去地支.add(地支)
                print(f"地支 {地支} 第二次合去")
            
            # 更新合次数
            地支合次数[地支] += 1
        
        # 处理合去的地支
        for 地支 in 合去:
            # 记录人元和库神消失
            本气 = 四库地支的本气.get(地支)
            for 藏干字 in 地支藏干字典.get(地支, []):
                if 藏干字 != 本气:
                    消失字典[藏干字] = f"('{地支}'的人元)"
                    已消失天干.add(藏干字)
            for 库神干 in 库神.get(地支, []):
                消失字典[库神干] = f"('{地支}'的库神)"
                已消失天干.add(库神干)
    
    return 合留, 合去


def 按顺序处理四柱关系(天干组合, 地支组合, 已消失天干, 已消失地支, 地支合次数):
    """
    按年→月→日→时的顺序处理四柱关系
    """
    print("\n开始处理四柱关系...")  # 调试信息
    
    有效地支 = list(地支组合)
    有效天干 = list(天干组合)
    最终会出者 = []
    处理序列 = [
        (0, 1, "年月"),  # 年支和月支
        (1, 2, "月日"),  # 月支和日支
        (2, 3, "日时")   # 日支和时支
    ]
    
    for i, j, 位置 in 处理序列:
        支1, 支2 = 有效地支[i], 有效地支[j]
        print(f"\n检查{位置}关系: {支1}-{支2}")  # 调试信息
        
        if not 支1 or not 支2 or 支1 in 已消失地支 or 支2 in 已消失地支:
            print(f"跳过{位置}处理：地支无效或已消失")  # 调试信息
            continue
            
        # 1. 检查六合
        组合 = f"{支1}{支2}"
        反组合 = f"{支2}{支1}"
        print(f"检查六合关系: {组合} 或 {反组合}")  # 调试信息
        if 组合 in 地支六合 or 反组合 in 地支六合:
            print(f"发现六合关系: {组合} 或 {反组合}")  # 调试信息
            六合对结果 = [(支1, 支2)]
            合留, 合去 = 处理地支六合(
                六合对结果, 天干组合, 地支组合, 最终会出者, 地支藏干字典, 已消失地支, 已消失天干, 地支合次数
            )
            for 地支 in 合去:
                print(f"地支 {地支} 因六合而消失")  # 调试信息
        
        # 2. 检查三会局
        if i == 0:  # 只在处理年月时检查三会局
            会出者 = 检查三会局([支1, 支2])
            if 会出者:
                最终会出者.extend(会出者)
                print(f"发现三会局会出者: {会出者}")  # 调试信息
    
        # 3. 检查三会方
        if i == 0:  # 只在处理年月时检查三会方
            刑冲合去地支 = 获取刑冲合去地支([支1, 支2])
            会出者 = 检查三会方([支1, 支2], 刑冲合去地支)
            if 会出者:
                最终会出者.extend(会出者)
                print(f"发现三会方会出者: {会出者}")  # 调试信息
    
        # 4. 检查刑冲关系
        # 检查刑
        if f"{支1}{支2}" in 刑字典 or f"{支2}{支1}" in 刑字典:
            print(f"发现刑: {支1}-{支2}")  # 调试信息
            处理刑冲结果(支1, 支2, "刑", 已消失地支, 已消失天干)
            print(f"地支 {支1} 和 {支2} 因刑而消失")  # 调试信息
            continue
            
        # 检查冲
        if f"{支1}{支2}" in 地支六冲 or f"{支2}{支1}" in 地支六冲:
            print(f"发现冲: {支1}-{支2}")  # 调试信息
            处理刑冲结果(支1, 支2, "冲", 已消失地支, 已消失天干)
            print(f"地支 {支1} 和 {支2} 因冲而消失")  # 调试信息
            continue
    
    print("\n四柱关系处理完成")  # 调试信息
    return list(set(最终会出者))


def 找出定局字(天干组合, 地支组合, 会出信息, 消失字典,打印信息=True):
    """找出命局中的定局字"""
    定局字集合 = set()
    
    # 1. 添加所有透干（年干月干时干）
    天干组合_无日干 = [天干组合[0], 天干组合[1], 天干组合[3]]  # 只取年干、月干、时干
    定局字集合.update(天干组合_无日干)
    if 打印信息:
        print("\n1. 透干定局字：", 定局字集合)
    
    # 2. 添加会出信息中的会出者
    for 信息 in 会出信息:
        会出者 = 信息.split('(')[0].strip()
        定局字集合.add(会出者)
    if 打印信息:
        print("2. 加入会出者后的定局字：", 定局字集合)
    
    # 3. 添加四正地支的本气
    for 地支 in 地支组合:
        if 地支 in 四正:  # 如果是四正地支
            if 地支 not in 消失字典:  # 只有当地支没有消失时才添加本气
                for 藏干 in 地支藏干字典.get(地支, []):
                    if 十天干五行对照表[藏干] == 十二地支五行对照表[地支]:  # 找出本气
                        定局字集合.add(藏干)
    if 打印信息:
        print("3. 加入四正地支本气后的定局字：", 定局字集合)
    
    # 4. 处理四库地支的本气（当四库地支消失时）
    四库本气对应 = {'辰': '戊', '戌': '戊', '丑': '己', '未': '己'}
    for 地支 in 四库:
        if 地支 in 消失字典:  # 如果四库地支消失了
            定局字集合.add(四库本气对应[地支])  # 添加对应的土元素本气
    if 打印信息:
        print("4. 加入消失的四库地支本气后的定局字：", 定局字集合)
    
    # 5和6. 处理四库地支的动字情况
    四库地支列表 = [支 for 支 in 地支组合 if 支 in 四库]  # 先筛选出四库地支
    for 地支 in 四库地支列表:  # 只遍历筛选出的四库地支
        if 地支 not in 消失字典:  # 只处理未消失的四库地支
            人元集合 = set(地支藏干字典.get(地支, []))
            库神集合 = set(库神.get(地支, []))
            全部字集合 = 人元集合 | 库神集合
            if 打印信息:
                print(f"\n处理四库地支{地支}:")
                print(f"人元集合: {人元集合}")
                print(f"库神集合: {库神集合}")
                print(f"全部字集合: {全部字集合}")
            
            # 检查是否有重复
            有重复 = False
            for 字 in 全部字集合:
                if 字 in 天干组合 or any(字 in 信息 for 信息 in 会出信息):
                    有重复 = True
                    定局字集合.add(字)  # 添加重复的字作为动字
            
            # 如果没有重复，添加土元素本气
            if not 有重复:
                定局字集合.add(四库本气对应[地支])
    if 打印信息:
        print("定局字：", 定局字集合)
    
    return 定局字集合


# 在命局所有信息展示函数中添加定局字的显示
def 命局所有信息展示(本命盘四个天干名字列表, 本命盘四个地支名字列表, options, 地支组合, 已消失天干, 已消失地支):
    """展示命局的所有相关信息"""
    
    print("\n《命局所有信息展示》")
    
    # Part1：基本信息
    print(f"天干四柱: 四个天干(年干='{本命盘四个天干名字列表.year}', "
          f"月干='{本命盘四个天干名字列表.month}', "
          f"日干='{本命盘四个天干名字列表.day}', "
          f"时干='{本命盘四个天干名字列表.time}')")
    print(f"地支四柱: 四个地支(年支='{本命盘四个地支名字列表.year}', "
          f"月支='{本命盘四个地支名字列表.month}', "
          f"日支='{本命盘四个地支名字列表.day}', "
          f"时支='{本命盘四个地支名字列表.time}')")
    print(f"性别：{'女' if options.n else '男'}")

    # Part2：人元和库神
    人元信息 = []
    库神信息 = []
    for 地支 in 地支组合:  # 使用传入的地支组合
        # 处理人元(地支藏干)信息
        if 地支 in 地支藏干字典:
            藏干 = 地支藏干字典[地支]
            if 藏干:  # 如果有藏干
                人元信息.append(f"{','.join(藏干)}(根:{地支})")
        # 处理库神信息
        if 地支 in 库神:
            库神列表 = 库神[地支]
            if 库神列表:  # 如果有库神
                库神信息.append(f"{','.join(库神列表)}(根:{地支})")
    
    print("人元(地支藏干)：" + '；'.join(人元信息))
    print("库神：" + '；'.join(库神信息))

    # Part3：会出者
    if 地支组合:
        会出信息 = []
        # 直接使用检查三会局函数的结果
        会出者 = 检查三会局(地支组合)
        if 会出者:
            地支集合 = set(地支组合)
            for 会局, 会出列表 in 三会局字典.items():
                if set(会局) <= 地支集合:
                    for 会出 in 会出列表:
                        if 会出 in 会出者:
                            会出信息.append(f"{会出} (由{list(会局)}会出)")
        
        # 直接使用检查三会方函数的结果
        刑冲合去地支 = 获取刑冲合去地支(地支组合)
        会出者 = 检查三会方(地支组合, 刑冲合去地支)
        if 会出者:
            for 三会组, 会出列表 in 三会方字典.items():
                if set(三会组) <= set(地支组合) and not set(三会组) & 刑冲合去地支:
                    for 会出 in 会出列表:
                        if 会出 in 会出者:
                            会出信息.append(f"{会出}(由{list(三会组)}会出)")
        
        print("会出者：" + ('；  '.join(会出信息) if 会出信息 else "无会出者"))

        # 显示本气信息
        本气信息 = []
        
        定局字集合 = 找出定局字(天干组合, 地支组合, 会出信息, 消失字典, 打印信息=False)

        # 检查四正地支的本气
        for 地支 in 地支组合:
            if 地支 in 四正:  # 如果是四正地支
                if 地支 not in 消失字典:  # 只有当地支没有消失时
                    本气 = 四正地支的本气[地支]
                    if 本气 in 定局字集合:
                        本气信息.append(f"{本气}(根:{地支})")
            
        # 检查四库地支的本气
        for 地支 in 地支组合:
            if 地支 in 四库:  # 如果是四库地支
                本气 = 四库地支的本气[地支]
                if 本气 in 定局字集合:
                    本气信息.append(f"{本气}(根:{地支})")
            
        print("本气：" + ('；'.join(本气信息) if 本气信息 else "无"))
    else:
        print("会出者：未提供地支组合")
        print("本气：未提供地支组合")



    # Part4：消失的字
    if len(消失字典) > 0:
        # 按照消失原因分组
        地支消失 = []
        人元消失 = {}  # 改用字典来收集同一地支的人元
        库神消失 = {}  # 改用字典来收集同一地支的库神
        
        for 字, 原因 in 消失字典.items():
            if "地支" in 原因:
                # 对于地支，标注是年支/月支/日支/时支
                位置 = ""
                for idx, dz in enumerate(地支组合):
                    if dz == 字:
                        if idx == 0:
                            位置 = "年支"
                        elif idx == 1:
                            位置 = "月支"
                        elif idx == 2:
                            位置 = "日支"
                        elif idx == 3:
                            位置 = "时支"
                        break
                地支消失.append(f"{字}({位置})")
            elif "人元" in 原因:
                # 提取地支名
                地支名 = 原因.split("'")[1]
                if 地支名 not in 人元消失:
                    人元消失[地支名] = []
                人元消失[地支名].append(字)
            elif "库神" in 原因:
                # 提取地支名
                地支名 = 原因.split("'")[1]
                if 地支名 not in 库神消失:
                    库神消失[地支名] = []
                库神消失[地支名].append(字)
        
        输出结果 = []
        # 添加地支消失信息
        if 地支消失:
            输出结果.append("、".join(地支消失))
        
        # 添加人元消失信息
        for 地支, 人元列表 in 人元消失.items():
            输出结果.append(f"{','.join(人元列表)}('{地支}'的人元)")
            
        # 添加库神消失信息
        for 地支, 库神列表 in 库神消失.items():
            输出结果.append(f"{','.join(库神列表)}('{地支}'的库神)")
        
        # 添加已消失天干信息
        if 已消失天干:
            天干消失信息 = [f"{天干} (已消失)" for 天干 in 已消失天干]
            输出结果.append("；".join(天干消失信息))
        
        # 添加已消失地支信息
        if 已消失地支:
            地支消失信息 = [f"{地支} (已消失)" for 地支 in 已消失地支]
            输出结果.append("；".join(地支消失信息))
        
        # 打印新增信息
        print("消失的字(十天干字): " + ('； '.join([f"{天干}" for 天干 in 已消失天干]) if 已消失天干 else "无"))
        print("消失的字(十二地支字): " + ('； '.join([f"{地支}" for 地支 in 已消失地支]) if 已消失地支 else "无"))
        print("刑冲: " + ('； '.join([f"{地支}" for 地支 in 刑冲地支]) if 刑冲地支 else "无"))
        print("合去: " + ('； '.join([f"{地支}" for 地支 in 合去地支]) if 合去地支 else "无"))

    # 按阴阳和五行属性排列定局字
    五行顺序 = ['木', '火', '土', '金', '水']
    阳字 = []
    阴字 = []

    # 将定局字按阴阳分组
    for 字 in 定局字集合:
        if 字的阴阳属性(字) == '阳':
            阳字.append(字)
        else:
            阴字.append(字)

    # 按五行顺序排列
    def 获取五行索引(字):
        return 五行顺序.index(十天干五行对照表[字])

    阳字.sort(key=获取五行索引)
    阴字.sort(key=获取五行索引)

    # 创建表格
    表格 = PrettyTable()
    表格.field_names = 五行顺序
    表格.header = False  # 不显示表头
    表格.border = False  # 不显示边框

    # 初始化阳行和阴行
    阳行 = [''] * 5
    阴行 = [''] * 5

    # 填充阳字
    for 字 in 阳字:
        五行 = 十天干五行对照表[字]
        位置 = 五行顺序.index(五行)
        阳行[位置] = 字

    # 填充阴字
    for 字 in 阴字:
        五行 = 十天干五行对照表[字]
        位置 = 五行顺序.index(五行)
        阴行[位置] = 字

    # 添加行到表格
    表格.add_row(阳行)
    表格.add_row(阴行)

    print("【定局字】")
    print(表格)

    定局字集合 = 找出定局字(天干组合, 地支组合, 会出信息, 消失字典, 打印信息=True)
    位置信息 = []
    
    # 处理透干
    透干位置 = {天干组合[0]: '[年干]',天干组合[1]: '[月干]',天干组合[3]: '[时干]'}
    
    # 处理地支位置
    地支位置 = {地支组合[0]: '[年支]',地支组合[1]: '[月支]',地支组合[2]: '[日支]',地支组合[3]: '[时支]'}
    
    已处理字 = set()
    for 字 in 定局字集合:
        if 字 in 已处理字:
            continue
            
        # 如果是透干
        if 字 in 透干位置:
            位置信息.append(f"{字}({透干位置[字]})")
            已处理字.add(字)
            continue
            
        # 如果是会出者
        会出根 = []
        for 信息 in 会出信息:
            if 字 == 信息.split('(')[0].strip():
                地支们 = eval(信息.split('由')[1].split(']')[0] + ']')
                根信息 = []
                for 地支 in 地支们:
                    if 地支 in 地支位置:
                        根信息.append(f"{地支}{地支位置[地支]}")
                if 根信息:
                    会出根.append(f"{字} (根:{', '.join(根信息)})")
                    已处理字.add(字)
                    
        if 会出根:
            位置信息.extend(会出根)
            continue
            
        # 如果是本气
        for 地支 in 地支组合:
            if (地支 in 四正 and 地支 not in 消失字典 and 
                字 == 四正地支的本气.get(地支)) or (
                地支 in 四库 and 字 == 四库地支的本气.get(地支)):
                位置信息.append(f"{字}(根:{地支}{地支位置[地支]})")
                已处理字.add(字)
                break
    
    print('；  '.join(位置信息))


    # 位置映射字典
    位置对应表 = {'年支': 0, '月支': 1, '日支': 2, '时支': 3, '年干': 0, '月干': 1, '日干': 2, '时干': 3}
    # 简化位置名称
    简化位置名 = {0: '[年]', 1: '[月]', 2: '[日]', 3: '[时]'}
    # 收集每个字的位置信息
    字的位置集合 = {}
    
    import re
    for 行 in 位置信息:
        # 分离字和位置信息
        字部分, 分隔, 括号部分 = 行.partition("(")
        字 = 字部分.strip(" ；")
        括号部分 = 括号部分.strip(")； ")
        
        # 找出所有[...]中的内容
        所有括号 = re.findall(r'\[(.*?)\]', 括号部分)
        
        # 找出最靠后的位置
        最大位置值 = -1
        for 位置名 in 所有括号:
            位置值 = 位置对应表.get(位置名, -1)
            if 位置值 > 最大位置值:
                最大位置值 = 位置值
        
        # 记录位置信息
        if 字 not in 字的位置集合:
            字的位置集合[字] = []
        字的位置集合[字].append(最大位置值)
    
    # 确定最终位置
    最终位置 = {}
    for 字, 位置列表 in 字的位置集合.items():
        if not 位置列表:
            continue
        选定位置值 = min(位置列表)  # 选最靠前的位置
        位置字符串 = 简化位置名.get(选定位置值, '[无]')
        最终位置[字] = 位置字符串
    
    print("\n满足条件的最后一个位置：")
    for 字 in sorted(最终位置.keys()):
        print(f"{字}：{最终位置[字]}")




import itertools

# 定义作用的分数变化
作用分数 = {
    '生': {'减分': 1.0, '增分': 1.0},
    '克': {'减分': 0.0, '增分': -1.0},
    '耗': {'减分': 0.6, '增分': 0.0},
    '泄': {'减分': 1.0, '增分': 0.0},  # 泄按与生类似处理
    '同': {'减分': 0.5, '增分': 0.0}   # '同'的处理需要特殊逻辑
}

# 位置顺序的定义
位置顺序 = {"年": 1, "月": 2, "日": 3, "时": 4}

# 初始化分数
def 初始化分数(定局字):
    return {字: 1.0 for 字 in 定局字}

# 识别所有“同”组合
def 识别同组合(定局字):
    同组合 = []
    for A, B in itertools.combinations(定局字, 2):
        五行A = 十天干的五行和阴阳表[A][1]
        五行B = 十天干的五行和阴阳表[B][1]
        if 五行A == 五行B and 五行作用关系.get((五行A, 五行B)) == '同':
            同组合.append((A, B))
    return 同组合

# 处理“同”组合
def 处理同组合(定局字, scores, 作用值):
    同组合 = 识别同组合(定局字)
    if not 同组合:
        print("没有发现'同'组合。")
        return 同组合

    print(f"发现'同'组合: {同组合}")

    # 如果有多个“同”组合
    if len(同组合) > 1:
        print("有多个'同'组合，进行检查是否能被其他字克或泄。")
        for 组 in 同组合:
            A, B = 组
            被克或泄 = False
            for 字 in 定局字:
                if 字 not in 组:
                    五行字 = 十天干的五行和阴阳表[字][1]
                    # 检查字是否克或泄 A 或 B
                    if 五行作用关系.get((五行字, 十天干的五行和阴阳表[A][1])) in ['克', '泄'] or \
                       五行作用关系.get((五行字, 十天干的五行和阴阳表[B][1])) in ['克', '泄']:
                        被克或泄 = True
                        print(f"字'{字}' 能克或泄组合{组}中的一个字。")
                        break
            if not 被克或泄:
                # 该组“同”无法被克或泄，无法解除封印
                print(f"组合{组}无法被任何字克或泄，无法解除封印。")
                return "定局字里没有格神😕"

        # 如果所有“同”组合都能被克或泄，则无格神
        print("所有'同'组合都能被克或泄，无法确定格神。")
        return "定局字里没有格神😕"

    # 只有一个“同”组合
    if len(同组合) == 1:
        A, B = 同组合[0]
        print(f"只有一个'同'组合: {A} 和 {B}，将其分数和作用值降为50%。")
        scores[A] *= 0.5
        scores[B] *= 0.5
        作用值[A] *= 0.5
        作用值[B] *= 0.5
    return 同组合

# 应用作用规则
def 应用作用(定局字, scores, 作用值):
    print("开始应用作用规则。")
    for A, B in itertools.permutations(定局字, 2):
        五行A = 十天干的五行和阴阳表[A][1]
        五行B = 十天干的五行和阴阳表[B][1]
        关系 = 五行作用关系.get((五行A, 五行B))
        if not 关系:
            continue
        # 检查阴阳属性是否相同
        阴阳相同 = 十天干的五行和阴阳表[A][0] == 十天干的五行和阴阳表[B][0]
        if not 阴阳相同:
            当前作用值 = 作用值[A] * 0.3  # 异性作用降为30%
        else:
            当前作用值 = 作用值[A]
        # 根据关系调整分数
        if 关系 == '生':
            scores[A] -= 作用分数['生']['减分'] * 当前作用值
            scores[B] += 作用分数['生']['增分'] * 当前作用值
            print(f"{A} 生 {B}：{A} 减{作用分数['生']['减分'] * 当前作用值}，{B} 增{作用分数['生']['增分'] * 当前作用值}")
        elif 关系 == '克':
            scores[B] += 作用分数['克']['增分'] * 当前作用值
            print(f"{A} 克 {B}：{B} 减{abs(作用分数['克']['增分'] * 当前作用值)}")
        elif 关系 == '耗':
            scores[A] -= 作用分数['耗']['减分'] * 当前作用值
            print(f"{A} 耗 {B}：{A} 减{作用分数['耗']['减分'] * 当前作用值}")
        elif 关系 == '泄':
            scores[A] -= 作用分数['泄']['减分'] * 当前作用值
            print(f"{A} 泄 {B}：{A} 减{作用分数['泄']['减分'] * 当前作用值}")
    return scores

# 判断并确定“格神”
def 确定格神(定局字, scores, 同组合, 最终位置):
    print("开始确定格神。")
    if isinstance(同组合, str):
        print(同组合)
        return 同组合

    if 同组合:
        # 只有一组“同”，判断是否有一方被克或泄
        A, B = 同组合[0]
        print(f"判断'同'组合内的字是否被克或泄：{A} 和 {B}")
        A是否被克泄 = False
        B是否被克泄 = False
        for 字 in 定局字:
            if 字 != A and 字 != B:
                五行字 = 十天干的五行和阴阳表[字][1]
                关系克A = 五行作用关系.get((五行字, 十天干的五行和阴阳表[A][1]))
                关系克B = 五行作用关系.get((五行字, 十天干的五行和阴阳表[B][1]))
                if 关系克A in ['克', '泄']:
                    A是否被克泄 = True
                    print(f"字'{字}' 能克或泄 '{A}'。")
                if 关系克B in ['克', '泄']:
                    B是否被克泄 = True
                    print(f"字'{字}' 能克或泄 '{B}'。")

        # 判断情况
        if A是否被克泄 and not B是否被克泄:
            # B幸存，成为格神
            print(f"字'{B}' 在'同'组合中幸存，成为格神。")
            return f"格神是: {B}"
        elif B是否被克泄 and not A是否被克泄:
            # A幸存，成为格神
            print(f"字'{A}' 在'同'组合中幸存，成为格神。")
            return f"格神是: {A}"
        elif not A是否被克泄 and not B是否被克泄:
            # 两者都未被克泄，查看是否有其他字可以成为格神
            print(f"字'{A}' 和 '{B}' 都未被克或泄，查看其他字。")
            max_score = max(scores.values())
            格神候选 = [字 for 字, 分数 in scores.items() if 分数 == max_score and 字 not in [A, B]]
            if len(格神候选) == 1:
                print(f"选择得分最高的字作为格神: {格神候选[0]}")
                return f"格神是: {格神候选[0]}"
            else:
                print("没有唯一的格神，无法确定。")
                return "定局字里没有格神😕"
        else:
            # 两者都被克泄，没有格神
            print(f"字'{A}' 和 '{B}' 都被克或泄，没有格神。")
            return "定局字里没有格神😕"
    else:
        # 无“同”组合，应用三种定格神的方法
        print("无'同'组合，应用三种定格神的方法。")
        # 方法2: 君赖臣生型
        for A, B in itertools.permutations(定局字, 2):
            五行A = 十天干的五行和阴阳表[A][1]
            五行B = 十天干的五行和阴阳表[B][1]
            关系 = 五行作用关系.get((五行A, 五行B))
            if 关系 == '生':
                print(f"应用君赖臣生型：{A} 生 {B}，因此 {B} 是格神。")
                return f"格神是: {B}"

        # 方法3: 儿能救母型
        for A, B, C in itertools.permutations(定局字, 3):
            五行A = 十天干的五行和阴阳表[A][1]
            五行B = 十天干的五行和阴阳表[B][1]
            五行C = 十天干的五行和阴阳表[C][1]
            关系AB = 五行作用关系.get((五行A, 五行B))
            关系BC = 五行作用关系.get((五行B, 五行C))
            if 关系AB in ['克', '泄'] and 关系BC in ['克', '泄']:
                print(f"应用儿能救母型：{A} {关系AB} {B}，{B} {关系BC} {C}，因此 {A} 是格神。")
                return f"格神是: {A}"

        # 方法4: 母慈灭子型
        for A, B, C in itertools.permutations(定局字, 3):
            五行A = 十天干的五行和阴阳表[A][1]
            五行B = 十天干的五行和阴阳表[B][1]
            五行C = 十天干的五行和阴阳表[C][1]
            关系AB = 五行作用关系.get((五行A, 五行B))
            关系BC = 五行作用关系.get((五行B, 五行C))
            关系AC = 五行作用关系.get((五行A, 五行C))
            if 关系AB == '生' and 关系BC == '生' and 关系AC in ['克', '泄']:
                print(f"应用母慈灭子型：{A} 生 {B}，{B} 生 {C}，{A} {关系AC} {C}，因此 {B} 是格神。")
                return f"格神是: {B}"

        # 如果不符合任何方法，选择得分最高的字
        print("不符合任何定格神方法，选择得分最高的字。")
        max_score = max(scores.values())
        格神候选 = [字 for 字, 分数 in scores.items() if 分数 == max_score]
        if len(格神候选) == 1:
            print(f"选择得分最高的字作为格神: {格神候选[0]}")
            return f"格神是: {格神候选[0]}"
        else:
            print("没有唯一的格神，无法确定。")
            return "定局字里没有格神😕"
    
    print("完成确定格神。")
    return 格神_result


# 验证格神的有效性，考虑位置顺序
def 验证格神(格神, 定局字, 最终位置, scores):
    print("开始验证格神的有效性，考虑位置顺序。")
    格神五行 = 十天干的五行和阴阳表[格神][1]
    # 找出所有克或泄格神的字
    杀手 = []
    保镖 = []
    for 字 in 定局字:
        if 字 == 格神:
            continue
        五行字 = 十天干的五行和阴阳表[字][1]
        关系 = 五行作用关系.get((五行字, 格神五行))
        if 关系 in ['克', '泄']:
            杀手.append(字)
            print(f"字'{字}' 是格神'{格神}'的杀手。")
    if not 杀手:
        print(f"格神'{格神}'没有被任何杀手克或泄。")
        return 格神

    # 找出杀手的保镖
    for 杀 in 杀手:
        for 字 in 定局字:
            if 字 == 杀 or 字 == 格神:
                continue
            五行字 = 十天干的五行和阴阳表[字][1]
            关系 = 五行作用关系.get((五行字, 十天干的五行和阴阳表[杀][1]))
            if 关系 in ['克', '泄']:
                保镖.append(字)
                print(f"字'{字}' 是杀手'{杀}'的保镖。")

    # 比较保镖和杀手的出现顺序
    for 杀 in 杀手:
        for 保 in 保镖:
            杀位置 = 位置顺序.get(最终位置.get(杀, "时"), 5)
            保位置 = 位置顺序.get(最终位置.get(保, "时"), 5)
            if 保位置 > 位置顺序.get(最终位置.get(杀, "时"), 5):
                print(f"保镖'{保}'的出现顺序晚于杀手'{杀}'，格神'{格神}'被杀手'{杀}'消灭。")
                # 排除当前格神，重新选择格神
                return None
    print(f"格神'{格神}'通过位置顺序验证。")
    return 格神

# 应用位置顺序验证，并重新选择格神
def 位置顺序验证(格神, 定局字, 最终位置, scores):
    while True:
        验证结果 = 验证格神(格神, 定局字, 最终位置, scores)
        if 验证结果:
            # 验证通过，格神有效
            return 验证结果
        else:
            # 验证失败，重新选择格神
            # 排除上一个格神
            scores[格神] = -float('inf')
            print(f"重新选择格神，排除'{格神}'。")
            # 重新确定格神
            同组合 = 识别同组合(定局字)
            new_格神_result = 确定格神(定局字, scores, 同组合, 最终位置)
            if new_格神_result.startswith("格神是: "):
                格神 = new_格神_result.split(": ")[1]
                print(f"新选择的格神是: {格神}")
            else:
                # 无法确定格神
                return "定局字里没有格神😕"

# 定局字测试功能
def 定局字测试():
    # 获取用户输入的定局字
    输入定局字 = input("请输入你要测试的定局字（请用空格分隔）：").strip().split()
    定局字 = 输入定局字.copy()
    print(f"输入的定局字是：{定局字}")

    # 获取用户是否需要规划位置顺序
    规划位置 = input("要不要规划位置顺序？（如果不用，直接按回车键就行。 如果需要，用\"A[月] B[日] C[时]\"这种固定格式回复）：").strip()
    if 规划位置:
        # 解析位置
        最终位置 = {}
        for item in 规划位置.split():
            if '[' in item and ']' in item:
                字, 位置 = item.split('[')
                位置 = 位置.rstrip(']')
                if 位置 not in 位置顺序:
                    print(f"位置'{位置}'不合法，默认设为[时]。")
                    位置 = "时"
                最终位置[字] = 位置
            else:
                print(f"输入格式错误的项：{item}，忽略。")
        print("输入的字位置如下：")
        for 字, 位置 in 最终位置.items():
            print(f"{字}：[{位置}]")
    else:
        # 默认所有字的位置为[时]
        最终位置 = {字: "时" for 字 in 定局字}
        print("未规划位置顺序，所有字的位置设为[时]。")

    # 初始化分数
    scores = 初始化分数(定局字)
    print(f"初始化分数：{scores}")

    # 初始化作用值
    作用值 = {字: 1.0 for 字 in 定局字}
    print(f"初始化作用值：{作用值}")

    # 处理“同”组合
    同组合 = 处理同组合(定局字, scores, 作用值)

    # 如果处理“同”组合后已确定没有格神
    if isinstance(同组合, str):
        print(同组合)
        return

    # 应用作用规则，迭代直到分数稳定
    print("开始迭代应用作用规则，直到分数稳定。")
    前一次分数 = {}
    迭代次数 = 0
    最大迭代次数 = 10
    while 前一次分数 != scores and 迭代次数 < 最大迭代次数:
        前一次分数 = scores.copy()
        scores = 应用作用(定局字, scores, 作用值)
        迭代次数 += 1
        print(f"迭代{迭代次数}后的分数：{scores}")

    if 迭代次数 == 最大迭代次数:
        print("已达到最大迭代次数，分数可能未完全稳定。")

    # 确定“格神”
    格神_result = 确定格神(定局字, scores, 同组合, 最终位置)
    if 格神_result.startswith("格神是: "):
        格神 = 格神_result.split(": ")[1]
        # 验证格神的有效性，考虑位置顺序
        格神 = 验证格神(格神, 定局字, 最终位置, scores)
        if isinstance(格神, str):
            print(格神)
        else:
            print("定局字里没有格神😕")
    else:
        print(格神_result)

# 主程序入口
def 主程序():
    try:
        print("欢迎使用定局字-格神判定系统！")
        print("请输入命主的生日，或输入'定局字测试'进入测试模式。")
        用户输入 = input("请输入命令或'定局字测试'：").strip()
        if 用户输入 == "定局字测试":
            定局字测试()
        else:
            # 假设用户输入的是命主生日，具体解析方法需根据实际情况实现
            # 这里我们假设已有函数根据生日计算出“定局字”和“最终位置”
            # 你需要根据实际情况替换下面的示例代码
            # 示例：用户输入生日后自动计算“定局字”
            print("你选择了普通模式，开始根据生日计算定局字。")
            # 这里放置你已有的计算“定局字”的代码
            # 假设有函数叫做 "计算定局字" 返回定局字集合和最终位置
            定局字集合, 最终位置 = 计算定局字()
            print("定局字：", 定局字集合)
            print("\n满足条件的最后一个位置：")
            for 字 in sorted(最终位置.keys()):
                print(f"{字}：{最终位置[字]}")

            # 初始化分数
            scores = 初始化分数(定局字集合)
            print(f"初始化分数：{scores}")

            # 初始化作用值
            作用值 = {字: 1.0 for 字 in 定局字集合}
            print(f"初始化作用值：{作用值}")

            # 处理“同”组合
            同组合 = 处理同组合(定局字集合, scores, 作用值)

            # 如果处理“同”组合后已确定没有格神
            if isinstance(同组合, str):
                print(同组合)
                return

            # 应用作用规则，迭代直到分数稳定
            print("开始迭代应用作用规则，直到分数稳定。")
            前一次分数 = {}
            迭代次数 = 0
            最大迭代次数 = 10
            while 前一次分数 != scores and 迭代次数 < 最大迭代次数:
                前一次分数 = scores.copy()
                scores = 应用作用(定局字集合, scores, 作用值)
                迭代次数 += 1
                print(f"迭代{迭代次数}后的分数：{scores}")

            if 迭代次数 == 最大迭代次数:
                print("已达到最大迭代次数，分数可能未完全稳定。")

            # 确定“格神”
            格神_result = 确定格神(定局字集合, scores, 同组合, 最终位置)
            if 格神_result.startswith("格神是: "):
                格神 = 格神_result.split(": ")[1]
                # 验证格神的有效性，考虑位置顺序
                格神 = 验证格神(格神, 定局字集合, 最终位置, scores)
                if isinstance(格神, str):
                    print(格神)
                else:
                    print("定局字里没有格神😕")
            else:
                print(格神_result)

    except Exception as e:
        print("脚本运行过程中出现错误：", e)
    

# 假设的计算定局字函数，根据实际情况实现
def 计算定局字():
    # 这里应该根据命主的生日计算“定局字”和“最终位置”
    # 由于缺乏具体的计算规则，以下为示例返回值
    # 请根据实际需求替换
    # 示例1：戊、庚、壬、癸
    # 定局字集合1 = ["戊", "庚", "壬", "癸"]
    # 最终位置1 = {"戊": "年", "庚": "月", "壬": "日", "癸": "时"}
    
    # 示例2：根据用户输入的生日计算
    # 这里只是一个简单的示例，实际计算需要根据干支历法实现
    定局字集合 = ["戊", "庚", "壬", "癸"]  # 示例
    最终位置 = {"戊": "年", "庚": "月", "壬": "日", "癸": "时"}  # 示例
    return 定局字集合, 最终位置



if __name__ == "__main__":
    # 主程序入口
    options = 解析输入命令()
    if options.b:
        本命盘四个天干名字列表, 本命盘四个地支名字列表 = 根据干支直接计算八字(options)
    else:
        本命盘四个天干名字列表, 本命盘四个地支名字列表 = 根据公历日期计算八字(options)
    # 创建地支和天干组合列表
    地支组合 = [本命盘四个地支名字列表.year, 本命盘四个地支名字列表.month, 本命盘四个地支名字列表.day, 本命盘四个地支名字列表.time]
    天干组合 = [本命盘四个天干名字列表.year, 本命盘四个天干名字列表.month,本命盘四个天干名字列表.day, 本命盘四个天干名字列表.time]
    # 初始化已消失的天干和地支集合
    已消失天干 = set()
    已消失地支 = set()
    # 初始化地支合次数
    地支合次数 = {地支: 0 for 地支 in 地支列表}
    # 处理四柱之间的关系（六合、三会、刑冲等）
    按顺序处理四柱关系(天干组合, 地支组合, 已消失天干, 已消失地支, 地支合次数)
    # 显示命局信息
    命局所有信息展示(本命盘四个天干名字列表, 本命盘四个地支名字列表, options, 地支组合, 已消失天干, 已消失地支)

